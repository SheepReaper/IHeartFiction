using Microsoft.AspNetCore.Mvc;
using Microsoft.OpenApi;

using IHFiction.SharedKernel.Linking;

using MongoDB.Bson;
using IHFiction.SharedKernel.Pagination;
using IHFiction.SharedKernel.Infrastructure;

namespace IHFiction.FictionApi.Extensions;

internal static class OpenApiExtensions
{
    public static IServiceCollection AddOpenApiWithAuth(this IServiceCollection services, string baseUrl, string realm) => AddOpenApiWithAuth(services, new Uri(baseUrl), realm);

    public static IServiceCollection AddOpenApiWithAuth(this IServiceCollection services, Uri baseUrl, string realm) => services.AddOpenApi(options => options.AddDocumentTransformer((document, context, cancellationToken) =>
    {
        document.Info = new(document.Info)
        {
            // Title and version are already set
            Contact = new() { Email = "bgonza868+fictionadmin@gmail.com", Name = "Bryan Gonzalez" },
            Description = "i❤️Fiction platform content management and browsing API.\n[Experimental]: This API is in an unstable state. Use at risk of headache.",
            License = new() { Name = "MIT License", Identifier = "MIT" },
            Summary = "I❤️HFiction API - your gateway to creating and discovering amazing fictional stories. Front-end too limited? Try this.",
            TermsOfService = new("http://localhost") // I don't have ToS yet
        };

        document.AddComponent("OAuth2", new OpenApiSecurityScheme()
        {
            BearerFormat = "JWT",
            Description = "OAuth 2.0 authentication with OpenID Connect.",
            Flows = new()
            {
                AuthorizationCode = new()
                {
                    AuthorizationUrl = new(baseUrl, $"realms/{realm}/protocol/openid-connect/auth"),
                    RefreshUrl = new(baseUrl, $"realms/{realm}/protocol/openid-connect/token"),
                    Scopes = new Dictionary<string, string>
                    {
                        {"fiction_api", "Grants access to authenticated methods."}
                    },
                    TokenUrl = new(baseUrl, $"realms/{realm}/protocol/openid-connect/token")
                }
            },
            In = ParameterLocation.Header,
            OpenIdConnectUrl = new(baseUrl, $"realms/{realm}/.well-known/openid-configuration"),
            Scheme = "bearer",
            Type = SecuritySchemeType.OAuth2
        });

        document.Security ??= [];

        document.Security.Add(new()
        {
            {new("OAuth2"), ["fiction_api"]}
        });

        return Task.CompletedTask;
    }).AddSchemaTransformer(async (schema, context, ct) =>
    {
        var t = context.JsonTypeInfo.Type;

        if (t == typeof(Ulid) || t == typeof(Ulid?))
        {
            schema.Type = JsonSchemaType.Null | JsonSchemaType.String;
            schema.Description = "Universally Unique Lexicographically Sortable Identifier";
            schema.Format = "ulid";
            schema.Example = "01ARZ3NDEKTSV4RRFFQ69G5FAV";
        }

        if (t == typeof(ObjectId) || t == typeof(ObjectId?))
        {
            schema.Type = JsonSchemaType.Null | JsonSchemaType.String;
            schema.Description = "MongoDB ObjectID";
            schema.Format = "objectid";
            schema.Example = "507f191e810c19729de860ea";
        }

        if (t == typeof(ProblemDetails) || t == typeof(HttpValidationProblemDetails))
        {
            void Desc(string name, string text)
            {
                if (schema.Properties?.TryGetValue(name, out var prop) ?? false)
                    prop.Description ??= text;
            }

            Desc("type", "A URI reference [RFC3986] that identifies the problem type.");
            Desc("title", "A short, human-readable summary of the problem type.");
            Desc("status", "The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.");
            Desc("detail", "A human-readable explanation specific to this occurrence of the problem.");
            Desc("instance", "A URI reference that identifies the specific occurrence of the problem.");
            Desc("errors", "A dictionary of validation errors keyed by field name.");
        }

        if (t == typeof(ProblemDetails))
        {
            schema.Description ??= "Standard RFC 7807/9457 problem details payload.";
        }

        if (t == typeof(HttpValidationProblemDetails))
        {
            schema.Description ??= "An extension of the Standard RFC 7807/9457 problem details payload to include validation errors.";
        }

        static bool IsSeq(Type x) => x.IsGenericType
            && (x.GetGenericTypeDefinition() == typeof(IQueryable<>)
                || x.GetGenericTypeDefinition() == typeof(IEnumerable<>));

        if (IsSeq(t) && schema is OpenApiSchema arr && arr.Items is null)
        {
            var itemType = t.GetGenericArguments()[0];

            var item = await context.GetOrCreateSchemaAsync(itemType, null, ct);

            arr.Items = item is { DynamicRef: not null } r
                ? new OpenApiSchema { DynamicRef = r.DynamicRef }
                : item;
        }

        if (t.IsGenericType && t.GetGenericTypeDefinition() == typeof(LinkedPagedCollection<>))
        {
            var dataName = context.JsonTypeInfo.Options.PropertyNamingPolicy?.ConvertName(nameof(ICollectionResponse<>.Data)) ?? nameof(ICollectionResponse<>.Data);

            if (schema.Properties?.TryGetValue(dataName, out var data) == true
                && data is OpenApiSchema ds && ds.Items is null)
            {
                var linkedItem = typeof(Linked<>).MakeGenericType(t.GetGenericArguments()[0]);
                var li = await context.GetOrCreateSchemaAsync(linkedItem, null, ct);

                ds.Items = li is { DynamicRef: not null } lir
                    ? new OpenApiSchema { DynamicRef = lir.DynamicRef }
                    : li;
            }
        }


        if (t.IsGenericType && t.GetGenericTypeDefinition() == typeof(Linked<>))
        {
            var innerType = t.GetGenericArguments()[0];
            var inner = await context.GetOrCreateSchemaAsync(innerType, null, ct);
            var links = await context.GetOrCreateSchemaAsync(typeof(IEnumerable<LinkItem>), null, ct);
            var linksName = context.JsonTypeInfo.Options.PropertyNamingPolicy?.ConvertName(nameof(ILinks.Links)) ?? nameof(ILinks.Links);

            schema.Type = JsonSchemaType.Object;
            schema.Properties?.Clear();
            schema.AllOf = null;
            schema.Required = new HashSet<string> { linksName };
            schema.Properties = new Dictionary<string, IOpenApiSchema>
            {
                [linksName] = links
            };

            // This flattens the schema for NSwag to handle it correctly.
            if (inner.Properties != null)
            {
                foreach (var property in inner.Properties)
                {
                    schema.Properties?.Add(property);
                }
            }

            if (inner.Required != null)
            {
                foreach (var required in inner.Required)
                {
                    schema.Required?.Add(required);
                }
            }
        }
    }).AddOperationTransformer((op, context, _) =>
    {
        var parameters = op.Parameters ?? [];

        for (var i = 0; i < parameters.Count; i++)
        {
            if (parameters[i].Name?.Equals("fields", StringComparison.OrdinalIgnoreCase) ?? false)
            {
                parameters[i] = parameters[i].With(
                    description: "Comma-separated list of fields to include in the response",
                    example: "name,createdAt");
            }

            if (parameters[i].Name?.Equals("sort", StringComparison.OrdinalIgnoreCase) ?? false)
            {
                parameters[i] = parameters[i].With(
                    description: "Comma-separated list of fields and sort directions to sort results by",
                    example: "name asc, createdAt desc");
            }

            if (parameters[i].Name?.Equals("q", StringComparison.OrdinalIgnoreCase) ?? false)
            {
                parameters[i] = parameters[i].With(
                    description: "Simple string to find in supported object fields.",
                    example: "my_term");
            }

            if (parameters[i].Name?.Equals("page", StringComparison.OrdinalIgnoreCase) ?? false)
            {
                parameters[i] = parameters[i].With(
                    description: "1-indexed page number for pagination",
                    example: "1");
            }

            if (parameters[i].Name?.Equals("pageSize", StringComparison.OrdinalIgnoreCase) ?? false)
            {
                parameters[i] = parameters[i].With(
                    description: "Number of items to return per page",
                    example: "50");
            }
        }

        return Task.CompletedTask;
    }));

    public static OpenApiParameter With(this IOpenApiParameter parameter, string? description = null, string? example = null) => new()
    {
        Name = parameter.Name,
        AllowEmptyValue = parameter.AllowEmptyValue,
        AllowReserved = parameter.AllowReserved,
        Content = parameter.Content,
        Deprecated = parameter.Deprecated,
        Examples = parameter.Examples,
        Extensions = parameter.Extensions,
        In = parameter.In,
        Required = parameter.Required,
        Schema = parameter.Schema,
        Style = parameter.Style,
        Description = description,
        Example = example,
    };
}
