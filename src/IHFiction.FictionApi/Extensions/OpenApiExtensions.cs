using System.Reflection;

using Microsoft.AspNetCore.Authentication.OpenIdConnect;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.OpenApi;
using Microsoft.Extensions.Options;
using Microsoft.OpenApi;

using IHFiction.SharedKernel.Infrastructure;
using IHFiction.SharedKernel.Linking;
using IHFiction.SharedKernel.Pagination;

using MongoDB.Bson;

namespace IHFiction.FictionApi.Extensions;

internal static class OpenApiExtensions
{
    private static Func<OpenApiDocument, OpenApiDocumentTransformerContext, CancellationToken, Task> CreatePrimaryDocumentTransformer(string? oidcScheme) => async (document, context, cancellationToken) =>
    {
        var options = context.ApplicationServices
            .GetRequiredService<IOptionsMonitor<OpenIdConnectOptions>>()
            .Get(oidcScheme);

        document.Security ??= [];

        if (Assembly.GetEntryAssembly()?.GetName().Name != "GetDocument.Insider" && options.ConfigurationManager is not null)
        {
            var oidcConfig = await options.ConfigurationManager.GetConfigurationAsync(cancellationToken);

            document.AddComponent("OAuth2", new OpenApiSecurityScheme()
            {
                Description = "OAuth 2.0 authentication with OpenID Connect.",
                Flows = new()
                {
                    AuthorizationCode = new()
                    {
                        AuthorizationUrl = new(oidcConfig.AuthorizationEndpoint),
                        RefreshUrl = new(oidcConfig.TokenEndpoint),
                        Scopes = new Dictionary<string, string>
                        {
                            {"fiction_api", "Grants access to authenticated methods."}
                        },
                        TokenUrl = new(oidcConfig.TokenEndpoint)
                    }
                },
                Type = SecuritySchemeType.OAuth2
            });

            document.Security.Add(new()
            {
                {new("OAuth2"), ["fiction_api"]}
            });
        }

        if (options.MetadataAddress is not null)
        {
            document.AddComponent("OpenIdConnect", new OpenApiSecurityScheme()
            {
                Description = "OpenID Connect authentication.",
                OpenIdConnectUrl = new(options.MetadataAddress),
                Type = SecuritySchemeType.OpenIdConnect
            });

            document.Security.Add(new()
            {
                {new("OpenIdConnect"), ["fiction_api"]}
            });
        }

        document.AddComponent("JWT", new OpenApiSecurityScheme()
        {
            BearerFormat = "JWT",
            Description = "JWT Bearer token authentication.",
            Scheme = OpenApiConstants.Bearer,
            Type = SecuritySchemeType.Http
        });

        document.Security.Add(new()
        {
            {new("JWT"), []}
        });

        document.Info = new(document.Info)
        {
            // Title and version are already set
            Contact = new() { Email = "bgonza868+fictionadmin@gmail.com", Name = "Bryan Gonzalez" },
            Description = "i❤️Fiction platform content management and browsing API.\n[Experimental]: This API is in an unstable state. Use at risk of headache.",
            License = new() { Name = "MIT License", Identifier = "MIT" },
            Summary = "I❤️HFiction API - your gateway to creating and discovering amazing fictional stories. Front-end too limited? Try this.",
            TermsOfService = new("http://localhost") // I don't have ToS yet
        };
    };

    private static async Task SchemaTransformer(OpenApiSchema schema, OpenApiSchemaTransformerContext context, CancellationToken ct)
    {
        var t = context.JsonTypeInfo.Type;

        if (t == typeof(Ulid) || t == typeof(Ulid?))
        {
            schema.Type = JsonSchemaType.Null | JsonSchemaType.String;
            schema.Description = "Universally Unique Lexicographically Sortable Identifier";
            schema.Format = "ulid";
            schema.Example = "01ARZ3NDEKTSV4RRFFQ69G5FAV";
        }

        if (t == typeof(ObjectId) || t == typeof(ObjectId?))
        {
            schema.Type = JsonSchemaType.Null | JsonSchemaType.String;
            schema.Description = "MongoDB ObjectID";
            schema.Format = "objectid";
            schema.Example = "507f191e810c19729de860ea";
        }

        if (t == typeof(ProblemDetails) || t == typeof(HttpValidationProblemDetails))
        {
            void Desc(string name, string text)
            {
                if (schema.Properties?.TryGetValue(name, out var prop) ?? false)
                    prop.Description ??= text;
            }

            Desc("type", "A URI reference [RFC3986] that identifies the problem type.");
            Desc("title", "A short, human-readable summary of the problem type.");
            Desc("status", "The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.");
            Desc("detail", "A human-readable explanation specific to this occurrence of the problem.");
            Desc("instance", "A URI reference that identifies the specific occurrence of the problem.");
            Desc("errors", "A dictionary of validation errors keyed by field name.");
        }

        if (t == typeof(ProblemDetails))
        {
            schema.Description ??= "Standard RFC 7807/9457 problem details payload.";
        }

        if (t == typeof(HttpValidationProblemDetails))
        {
            schema.Description ??= "An extension of the Standard RFC 7807/9457 problem details payload to include validation errors.";
        }

        static bool IsSeq(Type x) => x.IsGenericType
            && (x.GetGenericTypeDefinition() == typeof(IQueryable<>)
                || x.GetGenericTypeDefinition() == typeof(IEnumerable<>));

        if (IsSeq(t) && schema is OpenApiSchema arr && arr.Items is null)
        {
            var itemType = t.GetGenericArguments()[0];

            var item = await context.GetOrCreateSchemaAsync(itemType, null, ct);

            arr.Items = item is { DynamicRef: not null } r
                ? new OpenApiSchema { DynamicRef = r.DynamicRef }
                : item;
        }

        if (t.IsGenericType && t.GetGenericTypeDefinition() == typeof(LinkedPagedCollection<>))
        {
            var dataName = context.JsonTypeInfo.Options.PropertyNamingPolicy?.ConvertName(nameof(ICollectionResponse<>.Data)) ?? nameof(ICollectionResponse<>.Data);

            if (schema.Properties?.TryGetValue(dataName, out var data) == true
                && data is OpenApiSchema ds && ds.Items is null)
            {
                var linkedItem = typeof(Linked<>).MakeGenericType(t.GetGenericArguments()[0]);
                var li = await context.GetOrCreateSchemaAsync(linkedItem, null, ct);

                ds.Items = li is { DynamicRef: not null } lir
                    ? new OpenApiSchema { DynamicRef = lir.DynamicRef }
                    : li;
            }
        }

        if (t.IsGenericType && t.GetGenericTypeDefinition() == typeof(Linked<>))
        {
            var innerType = t.GetGenericArguments()[0];
            var inner = await context.GetOrCreateSchemaAsync(innerType, null, ct);
            var links = await context.GetOrCreateSchemaAsync(typeof(IEnumerable<LinkItem>), null, ct);
            var linksName = context.JsonTypeInfo.Options.PropertyNamingPolicy?.ConvertName(nameof(ILinks.Links)) ?? nameof(ILinks.Links);

            schema.Type = JsonSchemaType.Object;
            schema.Properties?.Clear();
            schema.AllOf = null;
            schema.Required = new HashSet<string> { linksName };
            schema.Properties = new Dictionary<string, IOpenApiSchema>
            {
                [linksName] = links
            };

            // This flattens the schema for NSwag to handle it correctly.
            if (inner.Properties != null)
            {
                foreach (var property in inner.Properties)
                {
                    schema.Properties?.Add(property);
                }
            }

            if (inner.Required != null)
            {
                foreach (var required in inner.Required)
                {
                    schema.Required?.Add(required);
                }
            }
        }
    }

    private static Task OperationTransformer(OpenApiOperation op, OpenApiOperationTransformerContext context, CancellationToken ct)
    {
        var parameters = op.Parameters ?? [];

        for (var i = 0; i < parameters.Count; i++)
        {
            if (parameters[i].Name?.Equals("fields", StringComparison.OrdinalIgnoreCase) ?? false)
            {
                parameters[i] = parameters[i].With(
                    description: "Comma-separated list of fields to include in the response",
                    example: "name,createdAt");
            }

            if (parameters[i].Name?.Equals("sort", StringComparison.OrdinalIgnoreCase) ?? false)
            {
                parameters[i] = parameters[i].With(
                    description: "Comma-separated list of fields and sort directions to sort results by",
                    example: "name asc, createdAt desc");
            }

            if (parameters[i].Name?.Equals("q", StringComparison.OrdinalIgnoreCase) ?? false)
            {
                parameters[i] = parameters[i].With(
                    description: "Simple string to find in supported object fields.",
                    example: "my_term");
            }

            if (parameters[i].Name?.Equals("page", StringComparison.OrdinalIgnoreCase) ?? false)
            {
                parameters[i] = parameters[i].With(
                    description: "1-indexed page number for pagination",
                    example: "1");
            }

            if (parameters[i].Name?.Equals("pageSize", StringComparison.OrdinalIgnoreCase) ?? false)
            {
                parameters[i] = parameters[i].With(
                    description: "Number of items to return per page",
                    example: "50");
            }
        }

        return Task.CompletedTask;
    }

    public static IServiceCollection AddOpenApiWithAuth(this IServiceCollection services, string? oidcScheme = null)
    {
        services.AddOpenApi(options => options
            .AddDocumentTransformer(CreatePrimaryDocumentTransformer(oidcScheme))
            .AddSchemaTransformer(SchemaTransformer)
            .AddOperationTransformer(OperationTransformer));

        return Assembly.GetEntryAssembly()?.GetName().Name == "GetDocument.Insider"
            ? services
            : services.AddOpenApi("cloudflare", options =>
        {
            options.OpenApiVersion = OpenApiSpecVersion.OpenApi2_0;

            options
                .AddDocumentTransformer(CreatePrimaryDocumentTransformer(oidcScheme))
                .AddDocumentTransformer((doc, ctx, ct) =>
                {
                    if(ctx.ApplicationServices.GetService<IConfiguration>()?["ApiBaseAddress"] is string apiBaseAddress)
                        doc.Servers = [new() { Url = apiBaseAddress.TrimEnd('/') }];

                    return Task.CompletedTask;
                })
                .AddSchemaTransformer(SchemaTransformer)
                .AddOperationTransformer(OperationTransformer);
        });
    }

    public static OpenApiParameter With(this IOpenApiParameter parameter, string? description = null, string? example = null) => new()
    {
        Name = parameter.Name,
        AllowEmptyValue = parameter.AllowEmptyValue,
        AllowReserved = parameter.AllowReserved,
        Content = parameter.Content,
        Deprecated = parameter.Deprecated,
        Examples = parameter.Examples,
        Extensions = parameter.Extensions,
        In = parameter.In,
        Required = parameter.Required,
        Schema = parameter.Schema,
        Style = parameter.Style,
        Description = description,
        Example = example,
    };
}
