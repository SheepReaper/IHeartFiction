@namespace IHFiction.SharedWeb.Components.MarkdownEditor
@using Microsoft.AspNetCore.Hosting
@using Microsoft.Extensions.Hosting
@rendermode RenderMode.InteractiveServer
@inherits CancellableComponent
@inject IJSRuntime JSRuntime
@inject ThemeService Theme
@inject IWebHostEnvironment Env

<HeadContent>
    <link href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css" rel="stylesheet" />

    @if (Theme.CurrentTheme == "dark")
    {
        <link href="https://uicdn.toast.com/editor/latest/theme/toastui-editor-dark.min.css" rel="stylesheet" />
    }
</HeadContent>

<div @ref="_editorElement"></div>

@code {
    [Parameter, EditorRequired]
    public required string Value { get; set; }

    [Parameter]
    public EventCallback<string> ValueChanged { get; set; }

    [Parameter]
    public EditorOptions Options { get; set; } = new();

    private ElementReference _editorElement;
    private DotNetObjectReference<Editor>? _dotNetObjectReference;
    private IJSObjectReference? _module;
    private IJSObjectReference? _editor;
    private bool _disposed;
    private string? _lastSetMarkdown;
    private bool _scriptsInitialized;

    protected override Task OnInitializedAsync()
    {
        Theme.ThemeChanged += OnThemeChanged;

        return Task.CompletedTask;
    }

    private async Task InitScriptsAsync()
    {
        if (_disposed) return;

        var scriptPath = "./_content/IHFiction.SharedWeb/Components/MarkdownEditor/Editor.razor.js";
        if (Env?.IsDevelopment() == true)
        {
            // Cache-bust in development so deployed/served files don't mask local edits
            scriptPath += "?v=" + DateTime.UtcNow.Ticks;
        }

        try
        {
            await JSRuntime.InvokeVoidAsync("console.log", "Editor importing script:", scriptPath);
        }
        catch { /* best-effort logging */ }

        _module = await JSRuntime.InvokeAsync<IJSObjectReference>(
        "import",
        CancellationToken,
        scriptPath);

        _editor = await _module.InvokeConstructorAsync(
        "BoundToast",
        CancellationToken,
        [Options, _dotNetObjectReference]);

        _scriptsInitialized = true;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_disposed) return;
        if (firstRender)
        {
            _dotNetObjectReference = DotNetObjectReference.Create(this);
            Options.Element = _editorElement;
            Options.InitialValue = Value ?? string.Empty;

            if (RendererInfo.IsInteractive)
                await InitScriptsAsync();
        }

        if (!_scriptsInitialized && RendererInfo.IsInteractive)
            await InitScriptsAsync();

        // Always update the editor content if Value changes, or if editor was just created
        if (_editor is not null && (Value != _lastSetMarkdown || firstRender) && _scriptsInitialized &&
        RendererInfo.IsInteractive)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("console.log", "Editor.setMarkdown called", new { ValueLength = (Value ?? string.Empty).Length, LastSetLength = _lastSetMarkdown?.Length });
            }
            catch { /* best-effort logging */ }

            await _editor.InvokeVoidAsync("setMarkdown", Value ?? string.Empty);
            _lastSetMarkdown = Value;
        }
    }

    private void OnThemeChanged(object? sender, ThemeChangedEventArgs e)
    {
        InvokeAsync(StateHasChanged);
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_disposed) return;
        // No-op: handled in OnAfterRenderAsync
        @* return Task.CompletedTask; *@
        if (_editor is not null && (Value != _lastSetMarkdown))
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("console.log", "Editor.OnParametersSetAsync setMarkdown", new { ValueLength = (Value ?? string.Empty).Length, LastSetLength = _lastSetMarkdown?.Length });
            }
            catch { /* best-effort logging */ }

            await _editor.InvokeVoidAsync("setMarkdown", Value ?? string.Empty);
            _lastSetMarkdown = Value;
        }
    }

    [JSInvokable]
    public async Task OnEditorContentChanged(string markdown)
    {
        try
        {
            if (_disposed) return;
            // Record the latest editor-originated markdown so we don't push it back
            // to the editor (calling setMarkdown) which causes the cursor to jump to the end.
            _lastSetMarkdown = markdown;
            Value = markdown;
            try
            {
                await JSRuntime.InvokeVoidAsync("console.log", "Editor.OnEditorContentChanged", new { Preview = markdown?.Length > 200 ? markdown.Substring(0, 200) + "..." : markdown });
            }
            catch { /* best-effort logging */ }
            if (ValueChanged.HasDelegate)
            {
                await ValueChanged.InvokeAsync(Value);
            }
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            await Console.Error.WriteLineAsync($"Editor.OnEditorContentChanged exception: {ex}");
            throw;
        }
    }

    protected override async ValueTask DisposeAsyncCore()
    {
        if (_disposed) return;

        Theme.ThemeChanged -= OnThemeChanged;

        try
        {
            if (_editor is not null)
            {
                await _editor.InvokeVoidAsync("destroy").ConfigureAwait(false);
                await _editor.DisposeAsync().ConfigureAwait(false);
            }

            if (_module is not null)
                await _module.DisposeAsync().ConfigureAwait(false);

            _editor = null;
        }
        catch (JSDisconnectedException)
        {
            // Swallow, expected on disconnect
            _editor = null;
            _module = null;
        }
        catch (Exception ex)
        {
            await Console.Error.WriteLineAsync($"Editor.DisposeAsyncCore exception: {ex}");
        }

        _module = null;

        _dotNetObjectReference?.Dispose();
        _dotNetObjectReference = null;

        _disposed = true;

        await base.DisposeAsyncCore().ConfigureAwait(false);
    }
}