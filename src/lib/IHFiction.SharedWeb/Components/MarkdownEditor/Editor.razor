@namespace IHFiction.SharedWeb.Components.MarkdownEditor
@using Microsoft.AspNetCore.Hosting
@using Microsoft.AspNetCore.Http
@using Microsoft.Extensions.Hosting
@using System.Text.RegularExpressions
@using System.Linq
@rendermode RenderMode.InteractiveServer
@inherits CancellableComponent
@inject IJSRuntime JSRuntime
@inject ThemeService Theme
@inject IWebHostEnvironment Env

<HeadContent>
    <link href="@Assets["_content/IHFiction.SharedWeb/editor/3.2.2/toastui-editor.min.css"]" rel="stylesheet"
        nonce="@nonce" />

    @if (Theme.CurrentTheme == "dark")
    {
        <link href="@Assets["_content/IHFiction.SharedWeb/editor/3.2.2/theme/toastui-editor-dark.min.css"]" rel="stylesheet"
            nonce="@nonce" />
    }
</HeadContent>

<div @ref="_editorElement"></div>

<!-- Editor status: word count always shown; character count shown when CharacterLimit is set -->
<div class="editor-status is-size-7 has-text-grey" aria-live="polite" role="status"
    style="margin-top:0.5rem; display:flex; justify-content:flex-end; gap:0.75rem;">
    <div class="word-count" title="Word count">Words: @_wordCount</div>
    @if (CharacterLimit.HasValue)
    {
        var exceeded = _charCount > CharacterLimit.Value;
        <div class="char-count" title="Character count">
            <span class="has-text-weight-semibold @(exceeded ? "has-text-danger" : "has-text-grey-dark")">@_charCount</span>
            <span class="has-text-grey">/</span>
            <span class="has-text-grey">@CharacterLimit</span>
        </div>
    }
</div>

@code {
    [Parameter, EditorRequired]
    public required string Value { get; set; }

    [Parameter]
    public EventCallback<string> ValueChanged { get; set; }

    [Parameter]
    public EditorOptions Options { get; set; } = new();

    private ElementReference _editorElement;
    private DotNetObjectReference<Editor>? _dotNetObjectReference;
    private IJSObjectReference? _module;
    private IJSObjectReference? _editor;
    private bool _disposed;
    private string? _lastSetMarkdown;
    private bool _scriptsInitialized;
    private int _wordCount;
    private int _charCount;

    [CascadingParameter]
    public string? nonce { get; set; }

    protected override Task OnInitializedAsync()
    {
        Theme.ThemeChanged += OnThemeChanged;

        // Initialize counts from the incoming Value so the status bar shows immediately
        RecomputeCounts(Value);

        return Task.CompletedTask;
    }

    /// <summary>
    /// Optional maximum character limit to display as a tracker. If null, character tracker is hidden.
    /// </summary>
    [Parameter]
    public int? CharacterLimit { get; set; }

    private void RecomputeCounts(string? markdown)
    {
        if (string.IsNullOrEmpty(markdown))
        {
            _charCount = 0;
            _wordCount = 0;
        }
        else
        {
            _charCount = markdown.Length;
            // Split on whitespace and count non-empty tokens
            var tokens = Regex.Split(markdown.Trim(), "\\s+");
            _wordCount = tokens.Count(t => !string.IsNullOrWhiteSpace(t));
        }

        // Do not call StateHasChanged here; callers will trigger render as appropriate.
    }

    private async Task InitScriptsAsync()
    {
        if (_disposed) return;

        var scriptPath = "./_content/IHFiction.SharedWeb/Components/MarkdownEditor/Editor.razor.js";
        if (Env?.IsDevelopment() == true)
        {
            // Cache-bust in development so deployed/served files don't mask local edits
            scriptPath += "?v=" + DateTime.UtcNow.Ticks;
        }

        try
        {
            await JSRuntime.InvokeVoidAsync("console.log", "Editor importing script:", scriptPath);
        }
        catch { /* best-effort logging */ }

        _module = await JSRuntime.InvokeAsync<IJSObjectReference>(
        "import",
        CancellationToken,
        scriptPath);

        _editor = await _module.InvokeConstructorAsync(
        "BoundToast",
        CancellationToken,
        [Options, _dotNetObjectReference]);

        _scriptsInitialized = true;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_disposed) return;
        if (firstRender)
        {
            _dotNetObjectReference = DotNetObjectReference.Create(this);
            Options.Element = _editorElement;
            Options.InitialValue = Value ?? string.Empty;

            if (RendererInfo.IsInteractive)
                await InitScriptsAsync();
        }

        if (!_scriptsInitialized && RendererInfo.IsInteractive)
            await InitScriptsAsync();

        // Always update the editor content if Value changes, or if editor was just created
        if (_editor is not null && (Value != _lastSetMarkdown || firstRender) && _scriptsInitialized &&
        RendererInfo.IsInteractive)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("console.log", "Editor.setMarkdown called", new
                {
                    ValueLength = (Value ?? string.Empty).Length,
                    LastSetLength = _lastSetMarkdown?.Length
                });
            }
            catch { /* best-effort logging */ }

            await _editor.InvokeVoidAsync("setMarkdown", Value ?? string.Empty);
            _lastSetMarkdown = Value;
            // Recompute counts after we've updated the editor from an external Value
            RecomputeCounts(Value);
        }
    }

    private void OnThemeChanged(object? sender, ThemeChangedEventArgs e)
    {
        InvokeAsync(StateHasChanged);
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_disposed) return;
        // No-op: handled in OnAfterRenderAsync
        @* return Task.CompletedTask; *@
        if (_editor is not null && (Value != _lastSetMarkdown))
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("console.log", "Editor.OnParametersSetAsync setMarkdown", new
                {
                    ValueLength = (Value ?? string.Empty).Length,
                    LastSetLength = _lastSetMarkdown?.Length
                });
            }
            catch { /* best-effort logging */ }

            await _editor.InvokeVoidAsync("setMarkdown", Value ?? string.Empty);
            _lastSetMarkdown = Value;
            RecomputeCounts(Value);
        }
    }

    [JSInvokable]
    public async Task OnEditorContentChanged(string markdown)
    {
        try
        {
            if (_disposed) return;
            // Record the latest editor-originated markdown so we don't push it back
            // to the editor (calling setMarkdown) which causes the cursor to jump to the end.
            _lastSetMarkdown = markdown;
            Value = markdown;
            RecomputeCounts(markdown);
            try
            {
                await JSRuntime.InvokeVoidAsync("console.log", "Editor.OnEditorContentChanged", new
                {
                    Preview = markdown?.Length > 200
                        ? markdown.Substring(0, 200) + "..."
                        : markdown
                });
            }
            catch { /* best-effort logging */ }
            if (ValueChanged.HasDelegate)
            {
                await ValueChanged.InvokeAsync(Value);
            }
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            await Console.Error.WriteLineAsync($"Editor.OnEditorContentChanged exception: {ex}");
            throw;
        }
    }

    protected override async ValueTask DisposeAsyncCore()
    {
        if (_disposed) return;

        Theme.ThemeChanged -= OnThemeChanged;

        try
        {
            if (_editor is not null)
            {
                await _editor.InvokeVoidAsync("destroy").ConfigureAwait(false);
                await _editor.DisposeAsync().ConfigureAwait(false);
            }

            if (_module is not null)
                await _module.DisposeAsync().ConfigureAwait(false);

            _editor = null;
        }
        catch (JSDisconnectedException)
        {
            // Swallow, expected on disconnect
            _editor = null;
            _module = null;
        }
        catch (Exception ex)
        {
            await Console.Error.WriteLineAsync($"Editor.DisposeAsyncCore exception: {ex}");
        }

        _module = null;

        _dotNetObjectReference?.Dispose();
        _dotNetObjectReference = null;

        _disposed = true;

        await base.DisposeAsyncCore().ConfigureAwait(false);
    }
}