@using IHFiction.SharedWeb.Services
@using IHFiction.SharedWeb.Components.MarkdownEditor
@using IHFiction.SharedWeb.Components
@using System.Collections.ObjectModel
@using System.Linq
@using static IHFiction.SharedWeb.Services.StoryEditorService
@using static IHFiction.Data.Stories.Domain.StoryType

@inherits CancellableComponent
@inject StoryEditorService StoryEditorService

<div class="chapter-manager">
    @if (!string.IsNullOrEmpty(_errorMessage))
    {
        <div class="notification is-danger">
            <button class="delete" @onclick="e => _errorMessage = string.Empty"></button>
            <strong>Error:</strong> @_errorMessage
        </div>
    }
    <h3 class="subtitle">Chapters</h3>
    @if (Chapters is not null)
    {
        <nav class="pagination is-centered is-small" role="navigation" aria-label="chapters pagination"
            style="margin-bottom: 1.5rem;">
            <a class="pagination-previous" @onclick="e => SelectPreviousChapter()">&lt; Previous</a>
            <ul class="pagination-list">
                @{
                    var _sortedChaps = GetSortedChapters();
                }
                @for (int i = 0; i < _sortedChaps.Count; i++)
                {
                    var chapter = _sortedChaps[i];
                    <li @key="chapter.Id">
                        <a class="pagination-link @(chapter.Id == Chapter?.Id ? "is-current" : "")"
                            aria-label="Chapter @(i + 1)" title="@chapter.Title"
                            @onclick="async () => await SelectChapter(chapter)">@(i + 1)</a>
                    </li>
                }
                <li>
                    <a class="pagination-link" aria-label="Add Chapter" @onclick="AddNewChapter">
                        <span class="icon is-small">
                            <i class="fas fa-plus"></i>
                        </span>
                    </a>
                </li>
            </ul>
            <a class="pagination-next" @onclick="e => SelectNextChapter()">Next &gt;</a>
        </nav>
    }
    else
    {
        <div class="has-text-centered">
            <p>Loading chapters...</p>
        </div>
    }
    <div>
        @if (Chapter is not null)
        {
            <div class="field">
                <label class="label">Chapter Title</label>
                <div class="control">
                    <input class="input" type="text" @bind="Chapter.Title" @bind:event="oninput" />
                </div>
            </div>
            <div class="field">
                <label class="label">Author's Notes (Start)</label>
                <div class="control" style="height: 200px">
                    <Editor @bind-Value="Chapter.Note1" CharacterLimit="5000" />
                </div>
            </div>
            <div class="field">
                <label class="label">Chapter Content</label>
                <div class="control" style="height: 500px">
                    <Editor @bind-Value="Chapter.Content" CharacterLimit="1000000" />
                </div>
            </div>
            <div class="field">
                <label class="label">Author's Notes (End)</label>
                <div class="control" style="height: 200px">
                    <Editor @bind-Value="Chapter.Note2" CharacterLimit="5000" />
                </div>
            </div>
            <div class="field">
                <button class="button is-danger" @onclick="e => ShowDeleteModal(Chapter)">
                    <span class="icon is-small">
                        <i class="fas fa-trash"></i>
                    </span>
                    <span>Delete Chapter</span>
                </button>
            </div>
        }
        else
        {
            <div class="has-text-centered">
                <p>Select a chapter to edit its content or add a new one.</p>
            </div>
        }
    </div>
</div>


@if (_showDeleteModal && _chapterToDelete is not null)
{
    <div class="modal is-active">
        <div class="modal-background" @onclick="HideDeleteModal"></div>
        <div class="modal-card">
            <header class="modal-card-head">
                <p class="modal-card-title">Delete Chapter</p>
                <button class="delete" aria-label="close" @onclick="HideDeleteModal"></button>
            </header>
            <section class="modal-card-body">
                <p>Are you sure you want to permanently delete the chapter <strong>@_chapterToDelete.Title</strong>? This
                    action cannot be undone.</p>
            </section>
            <footer class="modal-card-foot">
                <button class="button is-danger" @onclick="ConfirmDeleteChapter">Delete</button>
                <button class="button" @onclick="HideDeleteModal">Cancel</button>
            </footer>
        </div>
    </div>
}

@code {
    private ChapterEditorModel? Chapter => StoryEditorService.CurrentChapter;
    private string? _errorMessage;
    private bool _disposed;


    protected override async Task OnInitializedAsync()
    {
        StoryEditorService.ChapterChanged += OnChapterChanged;
        StoryEditorService.BookChanged += OnBookChanged;

        if (StoryEditorService.CurrentChapter is not null) return;

        var _sorted = GetSortedChapters();
        if (_sorted.Count > 0)
            await SelectChapter(_sorted[0]);
    }

    private ObservableCollection<ChapterEditorModel>? Chapters => StoryEditorService.CurrentStory?.StoryType switch
    {
        MultiChapter => StoryEditorService.CurrentStory?.Chapters,
        MultiBook => StoryEditorService.CurrentBook?.Chapters,
        _ => null
    };

    // Provide a stable, order-sorted view for rendering and navigation
    private List<ChapterEditorModel> GetSortedChapters()
    {
        if (Chapters is null) return new List<ChapterEditorModel>();

        List<ChapterEditorModel> list = Chapters.OrderBy(c => c.Order).ThenBy(c => c.Title,
        StringComparer.InvariantCulture).ToList();
        return list;
    }

    private async Task AddNewChapter()
    {
        var result = await StoryEditorService.AddNewChapterAsync(CancellationToken);

        if (result.IsFailure)
        {
            _errorMessage = result.DomainError?.Description ?? "Unknown error adding chapter.";
            return;
        }

        await SelectChapter(result.Value);
    }

    private async Task SelectPreviousChapter()
    {
        if (Chapters is null) return; // Buttons should be disabled in these cases
        var _list = GetSortedChapters();
        if (_list.Count == 0 || Chapter == null) return;

        var selectedIndex = _list.FindIndex(c => c.Id == Chapter.Id);

        if (selectedIndex == -1) return;

        var previousIndex = selectedIndex == 0 ? _list.Count - 1 : selectedIndex - 1;

        await SelectChapter(_list[previousIndex]);
    }

    private async Task SelectNextChapter()
    {
        if (Chapters is null) return; // Buttons should be disabled in these cases
        var _list2 = GetSortedChapters();
        if (_list2.Count == 0 || Chapter == null) return;

        var selectedIndex = _list2.FindIndex(c => c.Id == Chapter.Id);

        if (selectedIndex == -1) return;

        var nextIndex = (selectedIndex + 1) % _list2.Count;

        await SelectChapter(_list2[nextIndex]);
    }

    private async Task SelectChapter(ChapterEditorModel chapter)
    {
        if (chapter.Id is null) return;

        var result = await StoryEditorService.LoadChapterAsync(chapter.Id.Value, CancellationToken);

        if (result.IsFailure) _errorMessage = result.DomainError?.Description ?? "Unknown error loading chapter.";

    }

    private bool _showDeleteModal = false;
    private ChapterEditorModel? _chapterToDelete;

    private void ShowDeleteModal(ChapterEditorModel chapter)
    {
        _chapterToDelete = chapter;
        _showDeleteModal = true;
    }

    private void HideDeleteModal()
    {
        _showDeleteModal = false;
        _chapterToDelete = null;
    }

    private async Task ConfirmDeleteChapter()
    {
        if (_chapterToDelete is null) return;
        var result = await StoryEditorService.DeleteChapterAsync(_chapterToDelete, CancellationToken);
        if (result.IsFailure)
        {
            _errorMessage = result.DomainError?.Description ?? "Unknown error deleting chapter.";
        }
        else
        {
            if (Chapters is null) return; // Should not happen, buttons should be disabled in these cases

            // Remove from collection and clear selection if needed
            var _sorted2 = GetSortedChapters();
            var sortedIdx = _sorted2.FindIndex(c => c.Id == _chapterToDelete.Id);
            if (sortedIdx != -1)
            {
                var underlyingIdx = Chapters.ToList().FindIndex(c => c.Id == _chapterToDelete.Id);
                if (underlyingIdx != -1)
                {
                    Chapters.RemoveAt(underlyingIdx);
                }

                if (Chapter?.Id == _chapterToDelete.Id)
                {
                    // Select next chapter if available, else clear selection
                    var refreshed = GetSortedChapters();
                    if (refreshed.Count > 0)
                        await SelectChapter(refreshed[sortedIdx % refreshed.Count]);
                    else
                        ClearCurrentChapter();
                }
            }
        }
        HideDeleteModal();
    }

    private void ClearCurrentChapter()
    {
        StoryEditorService.ClearChapter();
    }

    private void OnBookChanged(object? sender, BookChangedEventArgs e)
    {
        InvokeAsync(StateHasChanged);
    }

    private void OnChapterChanged(object? sender, ChapterChangedEventArgs e)
    {
        InvokeAsync(StateHasChanged);
    }

    protected override ValueTask DisposeAsyncCore()
    {
        if (_disposed) return ValueTask.CompletedTask;
        StoryEditorService.ChapterChanged -= OnChapterChanged;
        StoryEditorService.BookChanged -= OnBookChanged;
        _disposed = true;
        return base.DisposeAsyncCore();
    }
}