@using IHFiction.SharedWeb.Services
@using IHFiction.SharedWeb.Components.MarkdownEditor
@using IHFiction.SharedWeb.Components
@using System.Collections.ObjectModel
@using static IHFiction.SharedWeb.Services.StoryEditorService
@using static IHFiction.Data.Stories.Domain.StoryType

@inherits CancellableComponent
@inject StoryEditorService StoryEditorService

<div class="chapter-manager">
    @if (!string.IsNullOrEmpty(_errorMessage))
    {
        <div class="notification is-danger">
            <button class="delete" @onclick="e => _errorMessage = string.Empty"></button>
            <strong>Error:</strong> @_errorMessage
        </div>
    }
    <h3 class="subtitle">Chapters</h3>
    @if (Chapters is not null)
    {
        <nav class="pagination is-centered is-small" role="navigation" aria-label="chapters pagination"
            style="margin-bottom: 1.5rem;">
            <a class="pagination-previous" @onclick="e => SelectPreviousChapter()">&lt; Previous</a>
            <ul class="pagination-list">
                @for (int i = 0; i < Chapters.Count; i++)
                {
                    var chapter = Chapters[i];
                    <li @key="chapter.Id">
                        <a class="pagination-link @(chapter.Id == Chapter?.Id ? "is-current" : "")"
                            aria-label="Chapter @(i + 1)" title="@chapter.Title"
                            @onclick="async () => await SelectChapter(chapter)">@(i + 1)</a>
                    </li>
                }
                <li>
                    <a class="pagination-link" aria-label="Add Chapter" @onclick="AddNewChapter">
                        <span class="icon is-small">
                            <i class="fas fa-plus"></i>
                        </span>
                    </a>
                </li>
            </ul>
            <a class="pagination-next" @onclick="e => SelectNextChapter()">Next &gt;</a>
        </nav>
    }
    else
    {
        <div class="has-text-centered">
            <p>Loading chapters...</p>
        </div>
    }
    <div>
        @if (Chapter is not null)
        {
            <div class="field">
                <label class="label">Chapter Title</label>
                <div class="control">
                    <input class="input" type="text" @bind="Chapter.Title" @bind:event="oninput" />
                </div>
            </div>
            <div class="field">
                <label class="label">Author's Notes (Start)</label>
                <div class="control" style="height: 200px">
                    <Editor @bind-Value="Chapter.Note1" CharacterLimit="5000" />
                </div>
            </div>
            <div class="field">
                <label class="label">Chapter Content</label>
                <div class="control" style="height: 500px">
                    <Editor @bind-Value="Chapter.Content" CharacterLimit="1000000" />
                </div>
            </div>
            <div class="field">
                <label class="label">Author's Notes (End)</label>
                <div class="control" style="height: 200px">
                    <Editor @bind-Value="Chapter.Note2" CharacterLimit="5000" />
                </div>
            </div>
            <div class="field">
                <button class="button is-danger" @onclick="e => ShowDeleteModal(Chapter)">
                    <span class="icon is-small">
                        <i class="fas fa-trash"></i>
                    </span>
                    <span>Delete Chapter</span>
                </button>
            </div>
        }
        else
        {
            <div class="has-text-centered">
                <p>Select a chapter to edit its content or add a new one.</p>
            </div>
        }
    </div>
</div>


@if (_showDeleteModal && _chapterToDelete is not null)
{
    <div class="modal is-active">
        <div class="modal-background" @onclick="HideDeleteModal"></div>
        <div class="modal-card">
            <header class="modal-card-head">
                <p class="modal-card-title">Delete Chapter</p>
                <button class="delete" aria-label="close" @onclick="HideDeleteModal"></button>
            </header>
            <section class="modal-card-body">
                <p>Are you sure you want to permanently delete the chapter <strong>@_chapterToDelete.Title</strong>? This
                    action cannot be undone.</p>
            </section>
            <footer class="modal-card-foot">
                <button class="button is-danger" @onclick="ConfirmDeleteChapter">Delete</button>
                <button class="button" @onclick="HideDeleteModal">Cancel</button>
            </footer>
        </div>
    </div>
}

@code {
    private ChapterEditorModel? Chapter => StoryEditorService.CurrentChapter;
    private string? _errorMessage;
    private bool _disposed;


    protected override async Task OnInitializedAsync()
    {
        StoryEditorService.ChapterChanged += OnChapterChanged;
        StoryEditorService.BookChanged += OnBookChanged;

        if(StoryEditorService.CurrentChapter is not null) return;

        if (StoryEditorService.CurrentStory is { StoryType: MultiChapter, Chapters.Count: > 0 } story)
            await SelectChapter(story.Chapters[0]);

        if (StoryEditorService.CurrentBook is { Chapters.Count: > 0 } book)
            await SelectChapter(book.Chapters[0]);
    }

    @* private Task OnFirstLoad(object? sender, ChapterChangedEventArgs e){
        if(StoryEditorService)
    } *@

    private ObservableCollection<ChapterEditorModel>? Chapters => StoryEditorService.CurrentStory?.StoryType switch
    {
        MultiChapter => StoryEditorService.CurrentStory?.Chapters,
        MultiBook => StoryEditorService.CurrentBook?.Chapters,
        _ => null
    };

    private async Task AddNewChapter()
    {
        var result = await StoryEditorService.AddNewChapterAsync(CancellationToken);

        if (result.IsFailure)
        {
            _errorMessage = result.DomainError?.Description ?? "Unknown error adding chapter.";
            return;
        }

        await SelectChapter(result.Value);
    }

    private async Task SelectPreviousChapter()
    {
        if (Chapters is null) return; // Buttons should be disabled in these cases
        if (Chapters.Count == 0 || Chapter == null) return;

        var selectedIndex = Chapters.ToList().FindIndex(c => c.Id == Chapter.Id);

        if (selectedIndex == -1) return;

        var previousIndex = selectedIndex == 0 ? Chapters.Count - 1 : selectedIndex - 1;

        await SelectChapter(Chapters[previousIndex]);
    }

    private async Task SelectNextChapter()
    {
        if (Chapters is null) return; // Buttons should be disabled in these cases
        if (Chapters.Count == 0 || Chapter == null) return;

        var selectedIndex = Chapters.ToList().FindIndex(c => c.Id == Chapter.Id);

        if (selectedIndex == -1) return;

        var nextIndex = (selectedIndex + 1) % Chapters.Count;

        await SelectChapter(Chapters[nextIndex]);
    }

    private async Task SelectChapter(ChapterEditorModel chapter)
    {
        if (chapter.Id is null) return;

        var result = await StoryEditorService.LoadChapterAsync(chapter.Id.Value, CancellationToken);

        if (result.IsFailure) _errorMessage = result.DomainError?.Description ?? "Unknown error loading chapter.";

    }

    private bool _showDeleteModal = false;
    private ChapterEditorModel? _chapterToDelete;

    private void ShowDeleteModal(ChapterEditorModel chapter)
    {
        _chapterToDelete = chapter;
        _showDeleteModal = true;
    }

    private void HideDeleteModal()
    {
        _showDeleteModal = false;
        _chapterToDelete = null;
    }

    private async Task ConfirmDeleteChapter()
    {
        if (_chapterToDelete is null) return;
        var result = await StoryEditorService.DeleteChapterAsync(_chapterToDelete, CancellationToken);
        if (result.IsFailure)
        {
            _errorMessage = result.DomainError?.Description ?? "Unknown error deleting chapter.";
        }
        else
        {
            if (Chapters is null) return; // Should not happen, buttons should be disabled in these cases

            // Remove from collection and clear selection if needed
            var idx = Chapters.ToList().FindIndex(c => c.Id == _chapterToDelete.Id);
            if (idx != -1)
            {
                Chapters.RemoveAt(idx);
                if (Chapter?.Id == _chapterToDelete.Id)
                {
                    // Select next chapter if available, else clear selection
                    if (Chapters.Count > 0)
                        await SelectChapter(Chapters[idx % Chapters.Count]);
                    else
                        ClearCurrentChapter();
                }
            }
        }
        HideDeleteModal();
    }

    private void ClearCurrentChapter()
    {
        StoryEditorService.ClearChapter();
    }

    private void OnBookChanged(object? sender, BookChangedEventArgs e)
    {
        InvokeAsync(StateHasChanged);
    }

    private void OnChapterChanged(object? sender, ChapterChangedEventArgs e)
    {
        InvokeAsync(StateHasChanged);
    }

    protected override ValueTask DisposeAsyncCore()
    {
        if (_disposed) return ValueTask.CompletedTask;
        StoryEditorService.ChapterChanged -= OnChapterChanged;
        StoryEditorService.BookChanged -= OnBookChanged;
        _disposed = true;
        return base.DisposeAsyncCore();
    }
}