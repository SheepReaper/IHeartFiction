## AOT-Compatible Source Generator for IHeartFiction

Here's the source generator I created that automatically registers your `IEndpoint` implementations and `IUseCase` classes without using reflection, making it fully AOT-compatible.

### How It Works

The source generator:
1. **Scans for classes** implementing `IHFiction.FictionApi.Infrastructure.IEndpoint` 
2. **Scans for classes** implementing `IHFiction.FictionApi.Infrastructure.IUseCase`
3. **Generates registration methods** at compile-time
4. **Replaces reflection-based assembly scanning** with explicit registration

### Generated Code

The source generator produces code like this:

```csharp
// <auto-generated />
#nullable enable

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using IHFiction.FictionApi.Infrastructure;

using IHFiction.FictionApi.Account;
using IHFiction.FictionApi.Authors;
using IHFiction.FictionApi.Stories;
using IHFiction.FictionApi.Tags;

namespace IHFiction.FictionApi.Extensions;

internal static partial class EndpointExtensions
{
    /// <summary>
    /// Registers all endpoint implementations with the dependency injection container.
    /// This method is generated at compile-time and is AOT compatible.
    /// </summary>
    public static IServiceCollection AddGeneratedEndpoints(this IServiceCollection services)
    {
        services.TryAddEnumerable(ServiceDescriptor.Transient<IEndpoint, GetCurrentAuthorStories.Endpoint>());
        services.TryAddEnumerable(ServiceDescriptor.Transient<IEndpoint, CreateStory.Endpoint>());
        services.TryAddEnumerable(ServiceDescriptor.Transient<IEndpoint, DeleteStory.Endpoint>());
        // ... all 40+ endpoints
        return services;
    }

    /// <summary>
    /// Registers all use case implementations with the dependency injection container.
    /// This method is generated at compile-time and is AOT compatible.
    /// </summary>
    public static IServiceCollection AddGeneratedUseCases(this IServiceCollection services)
    {
        services.AddScoped<GetCurrentAuthorStories>();
        services.AddScoped<CreateStory>();
        services.AddScoped<DeleteStory>();
        // ... all use cases
        return services;
    }
}
```

### Usage

Your existing code remains unchanged:

```csharp
// In Program.cs - same as before
builder.Services.AddEndpoints();
builder.Services.AddUseCases();

// In startup configuration - same as before  
app.MapEndpoints();
```

The source generator runs at compile time and replaces the reflection-based `AddEndpoints()` and `AddUseCases()` methods with the generated `AddGeneratedEndpoints()` and `AddGeneratedUseCases()` calls.

### Implementation Details

**Source Generator Project**: `src/lib/IHFiction.SourceGenerators/`
- Uses Roslyn syntax analysis to find implementation classes
- Generates registration code as `EndpointRegistration.g.cs`

**Integration**: The API project references the source generator:
```xml
<ProjectReference Include="../lib/IHFiction.SourceGenerators/IHFiction.SourceGenerators.csproj" 
                  OutputItemType="Analyzer" 
                  ReferenceOutputAssembly="false" />
```
